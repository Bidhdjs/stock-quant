# Stock-Quant 项目二次开发规划

## 一、项目现有架构分析

### 1. 项目整体结构

```
stock-quant/
├── core/                       # 核心模块
│   ├── stock/                  # 数据源管理（akshare/baostock/futu）
│   ├── strategy/               # 策略模块
│   │   ├── indicator/          # 信号指标（买卖点检测）
│   │   └── trading/            # 交易策略（执行买卖）
│   ├── quant/                  # 回测引擎
│   ├── visualization/          # 可视化
│   ├── task/                   # 定时任务
│   └── notification/           # 通知模块
├── frontend/                   # Flask Web界面
├── common/                     # 公共工具
├── data/                       # 数据存储
└── settings.py                 # 全局配置
```

### 2. 核心模块关系

```
┌─────────────────────────────────────────────────────────────────────┐
│                          Frontend (Flask)                            │
└────────────────────────────────┬────────────────────────────────────┘
                                 │
┌────────────────────────────────▼────────────────────────────────────┐
│                      QuantManager (回测引擎)                         │
│  - run_backtest_enhanced_volume_strategy()                          │
│  - 使用 Backtrader 框架                                              │
└────────────────────────────────┬────────────────────────────────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        ▼                        ▼                        ▼
┌───────────────┐      ┌─────────────────┐      ┌─────────────────┐
│ StockManager  │      │ StrategyManager │      │IndicatorManager │
│ (数据源管理)   │      │  (交易策略)      │      │   (信号指标)     │
│ - akshare     │      │ - StrategyBase  │      │ - bt.Indicator  │
│ - baostock    │      │ - 自动发现注册    │      │ - 自动发现注册   │
│ - futu        │      └─────────────────┘      └─────────────────┘
└───────────────┘
```

### 3. 现有功能

| 模块 | 功能 | 状态 |
|------|------|------|
| 数据源 | 港股(akshare/futu)、A股(baostock)、美股(akshare) | ✅ 已实现 |
| 指标 | 增强成交量指标 (RSI+布林带+KDJ) | ✅ 已实现 |
| 策略 | 增强成交量策略 | ✅ 已实现 |
| 回测 | 基于 Backtrader 的回测系统 | ✅ 已实现 |
| 可视化 | Plotly 交互式图表 | ✅ 已实现 |
| 前端 | Flask Web 界面 | ✅ 已实现 |

---

## 二、VCP 策略集成方案

### 1. VCP 策略核心逻辑

VCP (Volatility Contraction Pattern) 是 Mark Minervini 提出的形态：

**筛选条件：**
- Stage 2 判断（趋势模板）
  - 价格 > 50MA > 150MA > 200MA（均线多头排列）
  - 200MA 呈上升趋势（至少1个月）
  - 价格比52周低点高30%以上
  - 价格在52周高点的25%范围内
  - 相对强度(RS)线向上

- VCP 形态判断
  - 收缩次数: 2-4 次
  - 最大收缩幅度: ≤ 50%
  - 最小收缩幅度: ≤ 15%
  - 持续时间: ≥ 2 周
  - 成交量收缩（5日均量 < 30日均量）
  - 尚未突破

### 2. 创建 VCP 指标文件

**文件路径**: `core/strategy/indicator/pattern/vcp_indicator.py`

```python
import numpy as np
import backtrader as bt
from scipy.signal import argrelextrema
from core.strategy.indicator.common import SignalRecordManager


class VCPIndicator(bt.Indicator):
    """
    VCP (Volatility Contraction Pattern) 波动收缩形态指标
    
    检测 Minervini 趋势模板 + VCP 形态
    """
    lines = (
        'stage2_pass',          # 是否处于 Stage 2
        'vcp_signal',           # VCP 买入信号
        'num_contractions',     # 收缩次数
        'max_contraction',      # 最大收缩幅度
        'min_contraction',      # 最小收缩幅度
        'rs_rating',            # 相对强度评级
    )
    
    params = (
        ('ma_50_period', 50),
        ('ma_150_period', 150),
        ('ma_200_period', 200),
        ('ma_trend_period', 20),      # 判断趋势的周期
        ('local_extrema_order', 10),  # 局部极值检测范围
        ('min_contractions', 2),      # 最少收缩次数
        ('max_contractions', 4),      # 最多收缩次数
        ('max_contraction_depth', 50),# 最大收缩深度%
        ('min_contraction_depth', 15),# 最小收缩深度%
        ('min_weeks', 2),             # 最少持续周数
        ('rs_threshold', 70),         # RS评级阈值
    )
    
    def __init__(self):
        self.signal_record_manager = SignalRecordManager()
        
        # 计算移动平均线
        self.ma_50 = bt.indicators.SMA(self.data.close, period=self.p.ma_50_period)
        self.ma_150 = bt.indicators.SMA(self.data.close, period=self.p.ma_150_period)
        self.ma_200 = bt.indicators.SMA(self.data.close, period=self.p.ma_200_period)
        
        # 52周高低点
        self.week_52_low = bt.indicators.Lowest(self.data.low, period=252)
        self.week_52_high = bt.indicators.Highest(self.data.high, period=252)
        
        # 成交量指标
        self.vol_ma_5 = bt.indicators.SMA(self.data.volume, period=5)
        self.vol_ma_30 = bt.indicators.SMA(self.data.volume, period=30)
        
    def next(self):
        # 初始化
        self.lines.stage2_pass[0] = 0
        self.lines.vcp_signal[0] = np.nan
        
        # 检查数据是否足够
        if len(self) < self.p.ma_200_period + self.p.ma_trend_period:
            return
            
        # Stage 2 判断
        stage2 = self._check_stage2()
        self.lines.stage2_pass[0] = 1 if stage2 else 0
        
        if stage2:
            # VCP 形态检测
            vcp_result = self._check_vcp()
            if vcp_result['is_vcp']:
                self.lines.vcp_signal[0] = self.data.close[0]
                self.lines.num_contractions[0] = vcp_result['num_contractions']
                self.lines.max_contraction[0] = vcp_result['max_contraction']
                self.lines.min_contraction[0] = vcp_result['min_contraction']
                
                # 记录信号
                self.signal_record_manager.add_signal_record(
                    self.data.datetime.date(0),
                    'VCP_BUY',
                    f"VCP形态: {vcp_result['num_contractions']}次收缩, "
                    f"幅度{vcp_result['min_contraction']:.1f}%-{vcp_result['max_contraction']:.1f}%"
                )
    
    def _check_stage2(self):
        """检查是否处于 Stage 2（上升趋势阶段）"""
        close = self.data.close[0]
        
        # 条件1: 价格在所有均线之上
        cond1 = close > self.ma_50[0] and close > self.ma_150[0] and close > self.ma_200[0]
        
        # 条件2: 均线多头排列 50MA > 150MA > 200MA
        cond2 = self.ma_50[0] > self.ma_150[0] > self.ma_200[0]
        
        # 条件3: 200MA 呈上升趋势
        ma200_slope = self.ma_200[0] - self.ma_200[-self.p.ma_trend_period]
        cond3 = ma200_slope > 0
        
        # 条件4: 价格比52周低点高30%
        cond4 = close > self.week_52_low[0] * 1.3
        
        # 条件5: 价格在52周高点的25%范围内
        cond5 = close > self.week_52_high[0] * 0.75
        
        return cond1 and cond2 and cond3 and cond4 and cond5
    
    def _check_vcp(self):
        """检查 VCP 形态"""
        result = {
            'is_vcp': False,
            'num_contractions': 0,
            'max_contraction': 0,
            'min_contraction': 0,
        }
        
        # 获取历史数据用于分析
        lookback = min(len(self), 252)  # 最多看1年
        highs = np.array([self.data.high[-i] for i in range(lookback)])[::-1]
        lows = np.array([self.data.low[-i] for i in range(lookback)])[::-1]
        
        # 找局部高低点
        local_high_idx = argrelextrema(highs, np.greater, order=self.p.local_extrema_order)[0]
        local_low_idx = argrelextrema(lows, np.less, order=self.p.local_extrema_order)[0]
        
        if len(local_high_idx) < 2 or len(local_low_idx) < 2:
            return result
        
        # 计算收缩（简化版）
        contractions = []
        for i in range(min(len(local_high_idx), len(local_low_idx))):
            if local_high_idx[i] < local_low_idx[i]:
                high_val = highs[local_high_idx[i]]
                low_val = lows[local_low_idx[i]]
                contraction = (high_val - low_val) / high_val * 100
                contractions.append(contraction)
        
        if len(contractions) < self.p.min_contractions:
            return result
        
        # 检查收缩是否递减（VCP特征）
        valid_contractions = []
        for c in reversed(contractions):
            if not valid_contractions or c > valid_contractions[-1]:
                valid_contractions.append(c)
            else:
                break
        
        num_c = len(valid_contractions)
        if not (self.p.min_contractions <= num_c <= self.p.max_contractions):
            return result
        
        max_c = max(valid_contractions)
        min_c = min(valid_contractions)
        
        # 检查收缩深度
        if max_c > self.p.max_contraction_depth:
            return result
        if min_c > self.p.min_contraction_depth:
            return result
        
        # 检查成交量收缩
        if self.vol_ma_5[0] >= self.vol_ma_30[0]:
            return result
        
        result['is_vcp'] = True
        result['num_contractions'] = num_c
        result['max_contraction'] = max_c
        result['min_contraction'] = min_c
        
        return result
```

### 3. 创建 VCP 交易策略

**文件路径**: `core/strategy/trading/pattern/vcp_strategy.py`

```python
import numpy as np
from common.logger import create_log
from core.strategy.indicator.pattern.vcp_indicator import VCPIndicator
from core.strategy.trading.common import StrategyBase

logger = create_log("vcp_strategy")


class VCPStrategy(StrategyBase):
    """VCP 波动收缩形态交易策略"""
    
    params = (
        ('stop_loss_pct', 0.08),      # 止损比例 8%
        ('take_profit_pct', 0.20),    # 止盈比例 20%
        ('trailing_stop_pct', 0.10),  # 移动止损 10%
    )
    
    def __init__(self):
        super().__init__()
        self.set_indicator(VCPIndicator())
        self.entry_price = None
        self.highest_price = None
        
    def next(self):
        if self.order:
            return
        
        # 更新最高价（用于移动止损）
        if self.position and self.data.high[0] > (self.highest_price or 0):
            self.highest_price = self.data.high[0]
        
        # 持仓时检查止损/止盈
        if self.position:
            self._check_exit()
        else:
            # 无持仓时检查买入信号
            if not np.isnan(self.indicator.lines.vcp_signal[0]):
                logger.info(f'*** VCP 买入信号 ***')
                logger.info(f'时间: {self.data.datetime.date(0)}')
                logger.info(f'价格: {self.data.close[0]}')
                logger.info(f'收缩次数: {self.indicator.lines.num_contractions[0]}')
                self.trading_strategy_buy()
                self.entry_price = self.data.close[0]
                self.highest_price = self.data.close[0]
                self.buy_signals_count += 1
    
    def _check_exit(self):
        """检查退出条件"""
        current_price = self.data.close[0]
        
        # 止损检查
        stop_loss_price = self.entry_price * (1 - self.p.stop_loss_pct)
        if current_price <= stop_loss_price:
            logger.info(f'*** 止损卖出 *** 价格: {current_price}')
            self.trading_strategy_sell()
            self.sell_signals_count += 1
            return
        
        # 止盈检查
        take_profit_price = self.entry_price * (1 + self.p.take_profit_pct)
        if current_price >= take_profit_price:
            logger.info(f'*** 止盈卖出 *** 价格: {current_price}')
            self.trading_strategy_sell()
            self.sell_signals_count += 1
            return
        
        # 移动止损检查
        if self.highest_price:
            trailing_stop = self.highest_price * (1 - self.p.trailing_stop_pct)
            if current_price <= trailing_stop:
                logger.info(f'*** 移动止损卖出 *** 价格: {current_price}')
                self.trading_strategy_sell()
                self.sell_signals_count += 1
                return
```

---

## 三、数据源整合封装方案

### 1. 统一数据源接口

**文件路径**: `core/stock/data_source_manager.py`

```python
from abc import ABC, abstractmethod
from enum import Enum
from typing import Optional, List
import pandas as pd
from common.logger import create_log
from core.stock.manager_common import standardize_stock_data

logger = create_log("data_source_manager")


class Market(Enum):
    """市场枚举"""
    HK = "HK"       # 港股
    CN = "CN"       # A股
    US = "US"       # 美股


class DataSourceBase(ABC):
    """数据源基类"""
    
    @abstractmethod
    def get_history(self, symbol: str, start_date: str, end_date: str, 
                    adjust: str = 'qfq') -> pd.DataFrame:
        """获取历史数据"""
        pass
    
    @abstractmethod
    def get_realtime(self, symbol: str) -> pd.DataFrame:
        """获取实时数据"""
        pass
    
    @property
    @abstractmethod
    def name(self) -> str:
        """数据源名称"""
        pass
    
    @property
    @abstractmethod
    def supported_markets(self) -> List[Market]:
        """支持的市场"""
        pass


class DataSourceManager:
    """
    统一数据源管理器
    
    支持多数据源自动切换和数据缓存
    """
    
    def __init__(self):
        self.sources = {}
        self.priority = []  # 数据源优先级
        self._init_sources()
    
    def _init_sources(self):
        """初始化所有数据源"""
        from core.stock.sources.akshare_source import AkshareSource
        from core.stock.sources.baostock_source import BaostockSource
        from core.stock.sources.futu_source import FutuSource
        from core.stock.sources.yfinance_source import YFinanceSource
        
        # 注册数据源
        self.register_source(AkshareSource())
        self.register_source(BaostockSource())
        self.register_source(FutuSource())
        self.register_source(YFinanceSource())
        
        # 设置优先级
        self.priority = ['futu', 'akshare', 'baostock', 'yfinance']
    
    def register_source(self, source: DataSourceBase):
        """注册数据源"""
        self.sources[source.name] = source
        logger.info(f"已注册数据源: {source.name}")
    
    def get_history(self, symbol: str, market: Market, 
                    start_date: str, end_date: str,
                    source_name: Optional[str] = None) -> pd.DataFrame:
        """
        获取历史数据（自动选择数据源）
        
        Args:
            symbol: 股票代码
            market: 市场
            start_date: 开始日期
            end_date: 结束日期
            source_name: 指定数据源（可选）
        """
        # 如果指定了数据源
        if source_name and source_name in self.sources:
            source = self.sources[source_name]
            if market in source.supported_markets:
                return source.get_history(symbol, start_date, end_date)
        
        # 按优先级尝试数据源
        for name in self.priority:
            if name not in self.sources:
                continue
            source = self.sources[name]
            if market not in source.supported_markets:
                continue
            try:
                df = source.get_history(symbol, start_date, end_date)
                if not df.empty:
                    logger.info(f"使用 {name} 获取 {symbol} 数据成功")
                    return df
            except Exception as e:
                logger.warning(f"{name} 获取数据失败: {e}")
                continue
        
        logger.error(f"所有数据源均无法获取 {symbol} 数据")
        return pd.DataFrame()
    
    def get_stock_list(self, market: Market, 
                       source_name: Optional[str] = None) -> List[str]:
        """获取股票列表"""
        pass  # 实现类似逻辑


# 全局实例
global_data_source_manager = DataSourceManager()
```

### 2. 各数据源适配器

创建以下文件：
- `core/stock/sources/__init__.py`
- `core/stock/sources/akshare_source.py`
- `core/stock/sources/baostock_source.py`
- `core/stock/sources/futu_source.py`
- `core/stock/sources/yfinance_source.py`

---

## 四、回测系统增强方案

### 1. 回测管理器增强

**文件路径**: `core/quant/backtest_manager.py`

```python
import backtrader as bt
import pandas as pd
from typing import Dict, List, Optional, Type
from dataclasses import dataclass
from common.logger import create_log

logger = create_log("backtest_manager")


@dataclass
class BacktestResult:
    """回测结果数据类"""
    strategy_name: str
    total_return: float
    max_drawdown: float
    sharpe_ratio: float
    win_rate: float
    total_trades: int
    trade_records: pd.DataFrame
    signal_records: pd.DataFrame
    equity_curve: pd.DataFrame
    
    def to_dict(self) -> dict:
        return {
            'strategy_name': self.strategy_name,
            'total_return': self.total_return,
            'max_drawdown': self.max_drawdown,
            'sharpe_ratio': self.sharpe_ratio,
            'win_rate': self.win_rate,
            'total_trades': self.total_trades,
        }


class BacktestManager:
    """
    增强回测管理器
    
    功能：
    - 支持多策略对比回测
    - 支持参数优化
    - 支持多周期回测
    - 自动生成回测报告
    """
    
    def __init__(self, init_cash: float = 1000000):
        self.init_cash = init_cash
        self.results: Dict[str, BacktestResult] = {}
    
    def run_single(self, data: pd.DataFrame, 
                   strategy_class: Type[bt.Strategy],
                   strategy_params: dict = None) -> BacktestResult:
        """运行单次回测"""
        cerebro = bt.Cerebro()
        
        # 加载数据
        data_feed = self._create_data_feed(data)
        cerebro.adddata(data_feed)
        
        # 设置资金和佣金
        cerebro.broker.set_cash(self.init_cash)
        
        # 添加策略
        if strategy_params:
            cerebro.addstrategy(strategy_class, **strategy_params)
        else:
            cerebro.addstrategy(strategy_class)
        
        # 添加分析器
        cerebro.addanalyzer(bt.analyzers.TimeReturn, _name="returns")
        cerebro.addanalyzer(bt.analyzers.DrawDown, _name="drawdown")
        cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name="sharpe")
        cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name="trades")
        
        # 运行回测
        results = cerebro.run()
        strategy = results[0]
        
        # 提取结果
        return self._extract_result(strategy, cerebro)
    
    def run_optimization(self, data: pd.DataFrame,
                        strategy_class: Type[bt.Strategy],
                        param_ranges: dict) -> List[BacktestResult]:
        """参数优化回测"""
        cerebro = bt.Cerebro()
        
        data_feed = self._create_data_feed(data)
        cerebro.adddata(data_feed)
        cerebro.broker.set_cash(self.init_cash)
        
        # 添加优化参数
        cerebro.optstrategy(strategy_class, **param_ranges)
        
        # 添加分析器
        cerebro.addanalyzer(bt.analyzers.TimeReturn, _name="returns")
        cerebro.addanalyzer(bt.analyzers.DrawDown, _name="drawdown")
        
        # 运行优化
        results = cerebro.run(maxcpus=1)  # 多核优化
        
        # 提取所有结果
        all_results = []
        for result in results:
            all_results.append(self._extract_result(result[0], cerebro))
        
        return sorted(all_results, key=lambda x: x.total_return, reverse=True)
    
    def run_compare(self, data: pd.DataFrame,
                   strategies: List[Type[bt.Strategy]]) -> Dict[str, BacktestResult]:
        """多策略对比回测"""
        results = {}
        for strategy_class in strategies:
            result = self.run_single(data, strategy_class)
            results[strategy_class.__name__] = result
        
        self.results = results
        return results
    
    def generate_report(self) -> str:
        """生成回测报告"""
        # TODO: 生成 HTML 报告
        pass
    
    def _create_data_feed(self, data: pd.DataFrame):
        """创建数据源"""
        class CustomPandasData(bt.feeds.PandasData):
            params = (
                ('datetime', None),
                ('open', 'open'),
                ('high', 'high'),
                ('low', 'low'),
                ('close', 'close'),
                ('volume', 'volume'),
                ('openinterest', -1)
            )
        
        if 'date' in data.columns:
            data = data.set_index('date')
        
        return CustomPandasData(dataname=data)
    
    def _extract_result(self, strategy, cerebro) -> BacktestResult:
        """提取回测结果"""
        # 实现结果提取逻辑
        pass
```

---

## 五、推荐的开发顺序

### 第一阶段：数据源整合（1-2周）

1. 创建 `core/stock/sources/` 目录和基础接口
2. 适配现有的 akshare、baostock、futu 数据源
3. 添加 yfinance 数据源（用于美股/国际市场）
4. 创建统一的 `DataSourceManager`
5. 添加数据缓存机制

### 第二阶段：VCP 策略集成（1周）

1. 创建 `core/strategy/indicator/pattern/` 目录
2. 实现 `VCPIndicator` 指标
3. 创建 `core/strategy/trading/pattern/` 目录
4. 实现 `VCPStrategy` 交易策略
5. 测试 VCP 策略回测

### 第三阶段：回测系统增强（1-2周）

1. 创建 `BacktestManager` 增强回测功能
2. 添加参数优化功能
3. 添加多策略对比功能
4. 生成回测报告

### 第四阶段：前端集成（1周）

1. 添加 VCP 筛选页面
2. 添加多策略对比页面
3. 添加数据源配置页面

---

## 六、新增文件结构

```
core/
├── stock/
│   ├── sources/                    # 新增：数据源适配器
│   │   ├── __init__.py
│   │   ├── base.py                 # 数据源基类
│   │   ├── akshare_source.py
│   │   ├── baostock_source.py
│   │   ├── futu_source.py
│   │   └── yfinance_source.py
│   └── data_source_manager.py      # 新增：统一管理器
│
├── strategy/
│   ├── indicator/
│   │   └── pattern/                # 新增：形态指标
│   │       ├── __init__.py
│   │       ├── vcp_indicator.py    # VCP 指标
│   │       └── cup_handle_indicator.py  # 杯柄形态（可扩展）
│   │
│   └── trading/
│       └── pattern/                # 新增：形态策略
│           ├── __init__.py
│           ├── vcp_strategy.py     # VCP 策略
│           └── breakout_strategy.py # 突破策略（可扩展）
│
└── quant/
    ├── backtest_manager.py         # 新增：增强回测管理器
    └── optimizer.py                # 新增：参数优化器
```

---

## 七、关键代码复用

现有项目中可以直接复用的代码：

| 模块 | 文件 | 用途 |
|------|------|------|
| 策略基类 | `trading/common.py` | `StrategyBase` 包含完整的订单管理和手续费计算 |
| 数据标准化 | `stock/manager_common.py` | `standardize_stock_data` 统一数据格式 |
| 可视化 | `visualization/visual_tools_plotly.py` | `plotly_draw` 交互式图表 |
| 日志 | `common/logger.py` | 统一日志管理 |
| 配置 | `settings.py` | 全局配置参数 |

您可以参考这个规划文档开始二次开发。需要我帮您创建具体的代码文件吗？
